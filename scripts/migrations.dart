// ignore_for_file: avoid_print

import 'dart:io';

import 'package:args/command_runner.dart';

final outputDir = Directory('lib/migrations');
final inputDir = Directory('migrations');

final runner = CommandRunner('migrations', 'Migrations tool for PixelTime');
void main(List<String> arguments) {
  ensureMigrationDirectories();

  runner.addCommand(CreateCommand());
  runner.addCommand(GenerateCommand());
  runner.run(arguments);
}

void ensureMigrationDirectories() {
  if (!inputDir.existsSync()) {
    inputDir.createSync();
  }
  if (!outputDir.existsSync()) {
    outputDir.createSync();
  }
}

class CreateCommand extends Command {
  CreateCommand() {
    argParser.addOption('name', abbr: 'n', help: 'The name of the migration');
  }

  @override
  String get name => 'create';
  @override
  String get description => 'Creates a new migration';

  @override
  Future<void> run() async {
    final name = argResults?['name'];
    if (name == null) {
      runner.printUsage();
      print(argParser.usage);
      exit(1);
    }
    final timestamp = DateTime.now().millisecondsSinceEpoch;
    final file = File('${inputDir.path}/${timestamp}_name.sql');
    file.createSync();
    file.writeAsStringSync('');
  }
}

class GenerateCommand extends Command {
  GenerateCommand();

  @override
  String get name => 'generate';
  @override
  String get description => 'Generates migrations from the input directory';

  @override
  Future<void> run() async {
    final migrations = <Migration>[];
    final files = inputDir.listSync();
    for (final f in files) {
      final fileName = f.path.split('/').last;
      final version = fileName.split('_').first;
      final data = File(f.path).readAsStringSync();
      migrations.add(Migration(version: version, data: data));
    }
    migrations.sort((a, b) => a.version.compareTo(b.version));
    String content =
        '''
// GENERATED FILE. DO NOT EDIT.
// This file is generated by the migrations tool for PixelTime on ${DateTime.now().toIso8601String()}.

import 'migration_model.dart';

const migrations = [
''';
    for (final m in migrations) {
      content +=
          '''
	Migration(
    version: ${m.version},
    data: r\'\'\'${m.data}\'\'\',
  ),
''';
    }
    content += '];';
    final outputFile = File('${outputDir.path}/generated.dart');
    outputFile.writeAsStringSync(content);
  }
}

class Migration {
  final String version;
  final String data;

  Migration({
    required this.version,
    required this.data,
  });
}
