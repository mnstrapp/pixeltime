// ignore_for_file: avoid_print

import 'dart:io';

import 'package:args/command_runner.dart';

final outputDir = Directory('lib/migrations');
final inputDir = Directory('migrations');

final runner = CommandRunner('migrations', 'Migrations tool for PixelTime');
void main(List<String> arguments) {
  ensureMigrationDirectories();

  runner.addCommand(CreateCommand());
  runner.addCommand(GenerateCommand());
  runner.run(arguments);
}

void ensureMigrationDirectories() {
  if (!inputDir.existsSync()) {
    inputDir.createSync();
  }
  if (!outputDir.existsSync()) {
    outputDir.createSync();
  }
}

class CreateCommand extends Command {
  CreateCommand() {
    argParser.addOption('name', abbr: 'n', help: 'The name of the migration');
  }

  @override
  String get name => 'create';
  @override
  String get description => 'Creates a new migration';

  @override
  Future<void> run() async {
    final name = argResults?['name'];
    if (name == null) {
      runner.printUsage();
      print(argParser.usage);
      exit(1);
    }
    final timestamp = DateTime.now().millisecondsSinceEpoch;
    final upFile = File('${inputDir.path}/${timestamp}_${name}_up.sql');
    final downFile = File('${inputDir.path}/${timestamp}_${name}_down.sql');
    upFile.createSync();
    upFile.writeAsStringSync('');
    downFile.createSync();
    downFile.writeAsStringSync('');
  }
}

class GenerateCommand extends Command {
  GenerateCommand();

  @override
  String get name => 'generate';
  @override
  String get description => 'Generates migrations from the input directory';

  @override
  Future<void> run() async {
    final upMigrations = <String, String>{};
    final downMigrations = <String, String>{};
    final files = inputDir.listSync();
    final upFiles = files.where((f) => f.path.endsWith('_up.sql')).toList();
    final downFiles = files.where((f) => f.path.endsWith('_down.sql')).toList();
    for (final f in upFiles) {
      final fileName = f.path.split('/').last;
      final version = fileName.split('_').first;
      final data = File(f.path).readAsStringSync();
      upMigrations[version] = data;
    }
    for (final f in downFiles) {
      final fileName = f.path.split('/').last;
      final version = fileName.split('_').first;
      final data = File(f.path).readAsStringSync();
      downMigrations[version] = data;
    }
    final migrations = upMigrations.entries
        .map(
          (e) => Migration(
            version: e.key,
            upData: e.value,
            downData: downMigrations[e.key] ?? '',
          ),
        )
        .toList();
    migrations.sort((a, b) => a.version.compareTo(b.version));
    String content =
        '''
// GENERATED FILE. DO NOT EDIT.
// This file is generated by the migrations tool for PixelTime on ${DateTime.now().toIso8601String()}.

import 'migration_model.dart';

const migrations = [
''';
    for (final m in migrations) {
      content +=
          '''
	Migration(
    version: ${m.version},
    upData: r\'\'\'${m.upData}\'\'\',
    downData: r\'\'\'${m.downData}\'\'\',
  ),
''';
    }
    content += '];';
    final outputFile = File('${outputDir.path}/generated.dart');
    outputFile.writeAsStringSync(content);
  }
}

class Migration {
  final String version;
  final String upData;
  final String downData;

  Migration({
    required this.version,
    required this.upData,
    required this.downData,
  });
}
